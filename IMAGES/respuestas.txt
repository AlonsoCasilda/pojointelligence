1 - Quieres editar un archivo nuevo mediante el editor vi. Si estas en modo comando, indica la secuencia de teclas Vi NombreDeFichero # > i > # PonerCosa > # escape > # :wq

2 - Indica el comando Linux que permite ver los datos de la CPU. Indica tambien, en que archivo del sistema se guarda dicha informacion. # cpuid /// #cat /proc/cpuinfo

3 - Indica los comandos Linux, por este orden, que permiten ver los dispositivos conectados al bus PCI, con informacion del driver del kernel y otros modulos, y los conectados al bus USB. # lspci ; uname -r ; lsusb

4 - Indica el comando que muestra los detalles de la ocupacion de la memoria y el archivo correspondiente del sistema donde se guarda esta informacion. # free # cat /proc/meminfo

5 - Indica el comando, o comandos, que muestra los procesos que se estan ejecutando en el sistema. Ademas, indica en que directorio se guardan los datos de dichos procesos.. #ps -a#Buscar

6 - Indica como usarias el comando ping para que enviara 5 peticiones a la direccion IP 192.55.22.18. #ping -c 5 192.55.2..18

7 - Indica el comando que usarias para ver el direccionamiento IP del equipo y el archivo del sistema donde se encuentran dichos datos #ifconfig #cat /etc/hosts

8 - Indica el comando que usarias para ver la tabla de enrutamiento del equipo. #route #netstat -rn

9 - Indica el comando que usarias para ver numericamente los procesos que estan escuchando solo en un puerto TCP determinado.#netstat -p | grep numeroDePuerto

10 - Indica como seria el comando que muestra solo la informacion de tu cuenta de usuario.(hazlo usando dos comandos diferentes).#id daniel #cat /etc/passwd | grep daniel

11 - Indica los comandos para crear un grupo y hacer que este sea el grupo propietario de los archivos creados a partir de ese momento en la sesion actual. #groupadd nombreDeGrupo # mirar

12 - Indica el comando para ver todos los grupos a los que pertenece el usuario user1,(hazlo usando dos comandos diferentes).#sudo groups nombreDeUsuario#cat /etc/passwd | grep daniel

13 - Indica los comandos para crear el grupo dam2 cuyo GID este en el rango (1-999) y hacer que este grupo sea el grupo secundario de tu usuario. #sudo groupadd -g 999  dam2 (uid con -u) #sudo usermod -a -G dam2 daniel

14 - Indica el comando para comprobar si el usuario user1 ha hecho alguna vez login en el sistema y el comando para ver si alguno de esos intentos ha sido defectuoso. #last user1 #lastb user1

15 - Indica el comando para impedir que el usuario user1 haga login en el sistema y el comando que le vuelve a permitir hacer login de nuevo en el sistema. #usermod -L user1 #usermod -U user1

16 - Indica los tipos de archivos que identifica Linux (con letra y descripcion) que pueden verse a la izquierda de los permisos al hacer un listado detallado con ls -l.
-	fichero normal
d	directorio
l	enlace simbolico
c	fichero de dispositivo de caracteres
b	fichero de dispositivo de bloques
p	tuberia
s	socket

17 - Tienes un archivo llamado exploit.sh. Indica el comando, parametros y argumentos para cambiarle los permisos actuales (rwxr--r--) y permitir que un usuario perteneciente al grupo del propietario pudiera leerlo, editarlo y ejecutarlo (hazlo de tres formas distintas). Introduce el comando para ver con detalles esos permisos # chmod g=rwx exploit.sh # chmod 774 exploit.sh # Mirar # ls -l exploit.sh

18 - Observa los permisos del comando /usr/bin/wall. El comando wall manda un mensaje a todos los usuarios que han hecho login en el sistema. ?Que ves diferente respecto a los permisos normales? ?Que significa dicho permiso? Para probarlo, crea un usuario nuevo. Desde otro terminal haz login con este usuario. Desde el primer terminal, siendo superusurio, introduce el comando wall asi: #  wall ESTE ES UN MENSAJE DEL ADMINISTRADOR. #ls -la /usr/bin/wall #tiene una s en la posicion de ejecutable de grupos #useradd usuarioPared #sudo login usuarioPared # meter contraseña # desde root mandamos el mensaje con el comando wall

19 - Crea un hardlink del archivo info2 llamado hlinfo2. Indica el comando para crearlo, el comando para ver los detalles de los inodos y el comando para borrarlo. ?Que sucede con los inodos del archivo y del hardlink? ?Como son los permisos de ambos archivos? #ln info2 hlinfo2 #ls -li info2 hlinfo2 #rm hlinfo2 #Sucede que los inodos son ambos los mismos(2), y los permisos tambien.
 
20 - Crea un softlink del archivo info2 llamado slinfo2. Indica el comando para crearlo, el comando para ver los detalles de los inodos y el comando para borrarlo. ?Que sucede con los inodos del archivo y del softlink? ?Como son los permisos de ambos archivos? #touch info2; ln -s info2 slinfo2 #ls -li info2 slinfo2 #rm slinfo2 #Sucede que los inodos son los mismos(1), y los permisos distintos. #El enlace simbolico tiene todos los permisos. 

21 - Realiza un script que añada registros de personas a una agenda. Para cada entrada se debe solicitar NOMBRE y TELÉFONO Los datos de cada contacto se añadiran en una sola linea a un archivo cuyo nombre se pasara como parametro al script. Se debera comprobar que el fichero existe para ir añadiendo los contactos al fichero hasta que se introduzca la palabra FIN. En caso de que el fichero no exista se terminara la ejecucion del script con codigo 1.
#! bin/bash 

echo Introduce un nombre
read nom
echo Introduce edad
read edad

echo $nom $edad >> agenda.txt

Y ya no se como seguir xD . Hasta aqui solicita los datos y los manda a agenda, pero
comprobar si agenda contiene ese nombre para parar no se muy bien como hacerlo.
hace falta un bucle que compruebe si ya existe en agenda.

1 - Indica el comando Linux que permite ver los datos de la CPU. # lscpu   cat /proc/cpuinfo

2 - Indica el comando que muestra los detalles de la ocupacion de la memoria en gigas. # free -g

3 - Indica los dos comandos mas usados que muestran los procesos que se estan ejecutando en el sistema. # top # ps -a

4 - Indica como usarias el comando ping para que envie 2 peticiones a la direccion IP 192.55.22.18. # ping -c 2 192.55.22.18

5 - Indica el comando que usarias para ver el direccionamiento IP del equipo #ifconfig

6 - Indica el comando que usarias para ver numericamente los procesos que estan escuchando solo en un puerto TCP determinado. # netstat -anp | grep (numero)

7 - Indica como seria el comando que muestra solo la informacion de tu cuenta de usuario a partir del contenido del fichero de cuentas. #grep nombreUsuario /etc/passwd #getent passwd nombreUsuario

8 - Indica el comando para crear un grupo #groupadd nombreGrupo

9 - Indica el comando para ver todos los grupos a los que pertenece el usuario user1 # groups user1

10 - Añade un usuario a un grupo # useradd -G nombreGrupoExistente -m nombreUsuarioNew

11 - Indica el comando para impedir que el usuario user1 haga login en el sistema #usermod -L nombreUsuario

12 - Indica el comando que le vuelve a permitir hacer login de nuevo en el sistema. #usermod -U nombreUsuario

13 - Tienes un archivo llamado exploit.sh. Indica el comando, parametros y argumentos para cambiarle   los permisos actuales (rwxr--r--) y permitir que un usuario cualquiera pudiera leerlo, editarlo y ejecutarlo. a) formato simbolico #chmod o=rwx xploit.sh b) formato numerico #chmod 777 xpoit.sh

14 - Crea un hardlink del archivo file llamado hlfile. Indica el comando para crearlo, el comando para ver los detalles de los inodosy el comando para borrarlo. ?Que sucede con los inodos del archivo y del hardlink? ?Como son los permisos de ambos archivos? #touch file   #ln file hlfile   #ls -li file hlfile

15 - Crea un softlink del archivo file llamado slfile. #ln -s file slfile

16 - Crea un script que reciba como argumento un nombre. Pedira al usuario que introduzca su edad por teclado. Mostrara por pantalla un mensaje que ponga el nombre recibido como argumento y la edad. Ademas, debera crear un usuario con ese nombre (#!/bin/bash ---> echo $variableArgumento dime tu edad -----> read variableEntrada -----> echo $variableArgumento tienes $variableEntrada años ----> sudo useradd $variableArgumento ---->getent passwd $1) # ./nombreScript.sh variableArgumento

Script: 
Cambiar permiso de ejecucion como usuario de script: chmod u+x nombreScript.sh
Cambiar permiso de ejecucion como grupo de script: chmod g+x nombreScript.sh


#!/bin/bash                                                                   
echo "Please enter a number greater than 100"                                 
read num                                                                      
while [ $num -le 100 ]                                                        
do                                                                            
    echo "$num is NOT greater than 100."                                      
    echo "Please enter a number greater than 100."                            
    read num                                                                  
done                                                                          
echo "Finally, $num is greater than 100"


Ejercicio 1:
Script que crea un archivo en el directorio actual con el comando touch. Su nombre estara formado por una cadena que introduce el usuario por el teclado mas la fecha actual en el siguiente formulario.
#!/bin/bash
echo -n "Introduce el nombre del fichero: "
read nombre
touch $nombre`date +%m_%d_%Y` 

Ejercicio3:
Script que pida al usuario dos numeros. A continuacion le pide que introduzca si quiere sumerlos o restarlos echo "Introduce operacion (+o-)". Tiene que mostrar el resultado, o bien, un mensaje de error si el usuario introduce una operacion diferente. Por ultimo calcula la media de los datos
#!/bin/bash
echo -n "Introduce el numero1:"
read num1
echo -n "Ahora introduce el numero2:"
read num2
echo -n "Introduce el operador (+ o -)"
read operacion
case $operacion in
    +) echo `expr $num1 + $num2`;;
    -) echo `expr $num1 - $num2`;;
    *) echo "Operacion Incorrecta";;
esac

echo "La media es:" `expr $(expr $num1 + $num2) / 2`

Ejercicio 4:
Script Crear un numero variable de archivos, seguin un valor solicitado al usuario por teclado y almacenado en la variable num. Los archivos se crean con el comando touch y sus nombres deberan ser : text1, text2...etc. Utiliza un bucle for para automatizar el proceso
#!/bin/bash
echo -n "Introduce el numero de archivos:"
read num
    for i in `seq 1 $num`
        do
        touch test.$i
    done
ls

Ejercicio 5:
Solicita al usuario el nombre de un archivo y a continuacion comprueba si existe en el directorio actual. Si es asi, muestra un mensaje indicandolo. En caso contrario devuelve el error al Shell.
#!/bin/bash
echo -n "Introduce el nombre del fichero:"
read nombre

Ejercicio 6:
Construye un programa comprobar que solicite un nombre y compruebe si figura en un archivo llamado lista
#!/bin/bash
Solicita al usuario
echo "Introduce nombre a buscar:"
read nombre
    grep $nombre listanombre > /dev/null
    if [ $? -eq 0 ]
    then
        echo "El nombre $nombre existe"
    else
        echo "El nombre $nombre no existe"
    fi

Ejercicio 7:
Script elabora un programa ociones que solicite un nombre y compruebe si figura en un archivo llamado lista
#!/bin/bash
echo "**************************"
echo "         OPCIONES         "
echo "         a) pwd           "
echo "         b)ls -al         "
echo "         c) date          "
echo "**************************"

echo "Introduce una opcion:"
read opcion

    case $opcion in
        a) pwd;;
        b) ls -al;;
        c) date ;;
        *) echo "Opcion Incorrecta"
    esac



test –f /dev/ttyS0	0 si el archivo existe
test ! –f /dev/ttyS0	0 si el archivo no existe
test –d /tmp	0 si el directorio existe
test –x `which ls`	sustituir la ubicacion de ls y luego (probar) test, si el usuario puede ejecutar
test 1 –eq 1	0 si tiene exito la comparacion numerica
test ! 1 –eq 1	NO – 0 si la comparacion falla
test 1 –ne 1	Mas facil, ejecutar test (probar) si hay desigualdad numerica
test “a” = “a”	0 si tiene exito la comparacion de cadenas
test “a” != “a”	0 si las cadenas son diferentes
test 1 –eq 1 –o 2 –eq 2	-o es OR: cualquiera de las opciones pueden ser igual
test 1 –eq 1 –a 2 –eq 2	-a es AND: ambas comparaciones deben ser iguales
--------------
#!/bin/bash

if grep -q root /etc/passwd; then
  echo root is in the password file
else
  echo root is missing from the password file
fi
-----------------------
#!/bin/bash

case "$1" in
hello|hi)
  echo "hello yourself"
  ;;
goodbye)
  echo "nice to have met you"
  echo "I hope to see you again"
  ;;
*)
  echo "I didn't understand that"
esac
-----------------------
#!/bin/bash

i=0
while [ $i -lt 10 ]; do
  echo $i
  i=$(( $i + 1))
done
​⁠  ​  ⁠ ⁠
echo "Done counting"



100 ejercicios

1. Listar todos los archivos del directorio bin.  $ ls /bin
2. Listar todos los archivos del directorio tmp. $ ls /tmp
3. Listar todos los archivos del directorio etc que empiecen por t en orden inverso.  $ ls -dr /etc/t*
4. Listar todos los archivos del directorio dev que empiecen por tty y tengan 5 caracteres.  $ ls /dev/tty??
5. Listar todos los archivos del directorio dev que empiecen por tty y acaben en 1,2,3 o 4. $ ls /dev/tty*[1-4]
6. Listar todos los archivos del directorio dev que empiecen por t y acaben en C1.  $ ls /dev/t*C1
7. Listar todos los archivos, incluidos los ocultos, del directorio raiz. $ ls -a /
8. Listar todos los archivos del directorio etc que no empiecen por t.  $ ls -d /etc/[^t]*
9. Listar todos los archivos del directorio usr y sus subdirectorios. $ ls -R /usr
10. Cambiarse al directorio tmp.  $ cd /tmp
11. Verificar que el directorio actual ha cambiado.  $ pwd
12. Mostrar el dia y la hora actual.  $ date +"%A %D - %r" #o simplemente DATE
13. Con un solo comando posicionarse en el directorio $HOME. $ cd /HOME
14. Verificar que se esta en el.  $ pwd
15. Listar todos los ficheros del directorio HOME mostrando su numero de inodo. $ ls -i
16. Borrar todos los archivos y directorios visibles de vuestro directorio PRUEBA. 
17. Crear los directorios dir1, dir2 y dir3 en el directorio PRUEBA. Dentro de dir1 crear el directorio dir11. Dentro del directorio dir3 crear el directorio dir31. Dentro del directorio dir31, crear los directorios dir311 y dir312.  mkdir PRUEBA ; touch PRUEBA/{.f_hidden1,.f_hidden2,.f_hidden3} ; touch PRUEBA/{file1,file2,file3} ; mkdir PRUEBA/{dir1,dir2,dir3} ; $ rm -rf PRUEBA/*
18. Copiar el archivo /etc/motd a un archivo llamado mensaje de vuestro 1/ 6 directorio PRUEBA. $ cp /etc/motd ./PRUEBA
19. Copiar mensaje en dir1, dir2 y dir3. $ cd PRUEBA $ cp mensaje dir1/mensaje && cp mensaje dir2/mensaje && cp mensaje dir3/mensaje
20. Comprobar el ejercicio anterior mediante un solo comando. $ ls -R PRUEBA
21. Copiar los archivos del directorio rc.d que se encuentra en /etc al directorio dir31. $ cp -r /etc/rc.d dir3 
22. Copiar en el directorio dir311 los archivos de /bin que tengan una a como segunda letra y su nombre tenga cuatro letras. $ cp -r /bin/?a?? PRUEBA/dir3/dir31/dir311
23. Copiar el directorio de otro usuario y sus subdirectorios debajo de dir11 (incluido el propio directorio).$ sudo cp -r ../user_other PRUEBA/dir1/dir11 $ cp -r ../user PRUEBA/dir1/dir11
24. Mover el directorio dir31 y sus subdirectorios debajo de dir2. $ mv PRUEBA/dir3/dir31 PRUEBA/dir2
25. Mostrar por pantalla los archivos ordinarios del directorio HOME y sus subdirectorios. $ ls -R $HOME
26. Ocultar el archivo mensaje del directorio dir3. $ mv PRUEBA/dir3/mensaje PRUEBA/dir3/.mensaje
27. Borrar los archivos y directorios de dir1, incluido el propio directorio. $ rm -rf PRUEBA/dir1
28. Copiar al directorio dir312 los ficheros del directorio /dev que empiecen por t, acaben en una letra que vaya de la a a la b y tengan cinco letras en su nombre. $ ls /dev/t???[a*b]
29. Borrar los archivos de dir312 que no acaben en b y tengan una q como cuarta letra.$ find dir312 -type f -regex ".*???q[^b$]" -exec rm -r {} \; 
30. Mover el directorio dir312 debajo de dir3. $ mv PRUEBA/dir2/dir31/dir312 PRUEBA/dir3
31. Crear un enlace simbolico al directorio dir1 dentro del directorio dir3 llamado enlacedir1. $ ln -s /home/usuario1/PRUEBA/dir1 PRUEBA/dir3/enlacedir1
32. Posicionarse en dir3 y, empleando el enlace creado en el ejercicio anterior, crear el directorio nuevo1 dentro de dir1. $ cd PRUEBA/dir3 $ mkdir enlacedir1/nuevo1
33. Utilizando el enlace creado copiar los archivos que empiecen por u del directorio /bin en directorio nuevo1. $ cp -r /bin/u* enlacedir1/nuevo1/
34. Crear dos enlaces duros del fichero fich1, llamarlo enlace, en los directorios dir1 y dir2. $ ln fich1 dir1/enlace $ ln fich1 dir2/enlace
35. Borrar el archivo fich1 y copiar enlace en dir3. $ rm fich1 $ cp dir1/enlace dir3/  $ ln -s /home/usuario1/PRUEBA/dir2/enlace /home/usuario1/PRUEBA/dir1/enlafich1
36. Crear un enlace simbolico (llamado enlafich1) al fichero enlace de dir2 en dir1. $ ln -s dir2/enlace dir1/enlafich1
37. Posicionarse en dir1 y, mediante el enlace creado, copiar el archivo fichl dentro de dir311. $ cd dir1 dir1$ cp enlafich1 ../dir2/dir31/dir311/fich1
38. Seguir en dir1 y, mediante el enlace creado, sacar por pantalla las lineas que tiene el archivo fich1. 2/ 6 dir1$ cat enlafich1
39. Borrar el fichero fich1 de dir2 PRUEBA$ rm dir2/fich1
40. Borrar todos los archivos y directorios creados durante los ejercicios. $ rm -r *
41. Crear el directorio dir2 y dir3 en el directorio PRUEBA ?Cuales son los actuales permisos del directorio dir2? $ mkdir dir1 dir2
42. Utilizando la notacion simbolica, eliminar todos los permisos de escritura (propietario, grupo, otros) del directorio dir2. $ chmod = dir1 
43. Utilizando la notacion octal, eliminar el permiso de lectura del directorio dir2, al resto de los usuarios.  $ chmod 751 dir2
44. ?Cuales son ahora los permisos asociados a dir2? $ ls -la ./dir2
45. Crear bajo dir2, un directorio llamado dir2l. $ mkdir dir2/dir21 no se puede crear
46. Concederse a si mismo permiso de escritura en el directorio dir2 e intentar de nuevo el paso anterior.  $ chmod 200 dir1 $ ls -l $ mkdir dir1/dir21 mkdir: no se puede crear el directorio «dir1/dir21»: Permiso denegado
47. ?Cuales son los valores por omision asignados a los archivos? $ touch dir1/{file1,file2,file3} PRUEBA$ ls -l dir1
48. Cambiar el directorio actual al directorio dir3. Imprimir su trayectoria completa para verificar el cambio. $ ls dir1 dir2 dir3 $ mv dir1 dir3/ $ ls -lR .: ./dir2: ./dir2/dir21: ./dir3: ./dir3/dir1:
49. ?Cuales son los permisos asignados en su momento a este directorio? $ ./dir3:
50. Establecer mediante el comando umask (buscar este comando) los siguientes valores por omision: rwxr--r-- para los directorios y rw-r--r-- para los archivos ordinarios.  $ umask 0033
51. Crear cuatro nuevos directorios llamados dira, dirb, dirc, y dird bajo el directorio actual. $ mkdir dira dirb dirc dird
52. Comprobar los permisos de acceso de los directorios recien creados para comprobar el funcionamiento del comando umask.  $ ls -l
53. Crear el fichero uno . Quitarle todos los permisos de lectura. Comprobarlo. Intentar borrar dicho fichero. $ touch uno $ chmod a-r uno $ ls -l $ rm uno $ _
54. Quitarle todos los permisos de paso al directorio dir2 y otorgarle todos los demas. $ chmod = dir2 $ chmod o=rwx dir2
55. Crear en el directorio propio: El directorio carpeta1 con los tres permisos para el propietario, dentro de el fich1 con lectura y escritura para todos y fich2 con lectura y escritura para el propietario y solo lectura para el resto. El directorio carpeta2 con todos los permisos para el propietario y lectura y ejecucion para los del mismo grupo. Dentro file1 con lectura y escritura para el propietario y los del grupo y file2 con los mismos para el propietario y solo lectura para el grupo. $ mkdir carpeta1 carpeta2 $ chmod u=rwx,g=,o= carpeta1 $ chmod u=rwx,g=rx,o= carpeta2 $ ls -l $ touch carpeta1/{fich1,fich2} $ chmod = carpeta1/{fich1,fich2} $ chmod o=rw carpeta1/fich1 $ ls -l carpeta1 $ touch carpeta2/{file1,file2} $ chmod = carpeta2/{file1,file2} $ chmod u=rw,g=rw carpeta2/file1 $ chmod u=rw,g=r carpeta2/file2 $ ls -l carpeta2
56. Desde otro usuario probar todas las operaciones que se pueden hacer en los ficheros y directorios creados. 3/ 6 .
$ su us3rlinux
 Contraseña:
## carpeta1 ##
# prueba de acceso
us3rlinux@equipo1:/home/usuario1/PRUEBA$ cd carpeta1
 bash: cd: carpeta1: Permiso denegado
# prueba de lectura
us3rlinux@equipo1:/home/usuario1/PRUEBA$ ls carpeta1
 ls: no se puede abrir el directorio carpeta1: Permiso denegado
## carpeta2 ##
# prueba de acceso
us3rlinux@equipo1:/home/usuario1/PRUEBA$ cd carpeta2
# prueba de lectura
us3rlinux@equipo1:/home/usuario1/PRUEBA/carpeta2$ ls -l
 total 0
 -rw-rw---- 1 usuario1 usuario1 0 2009-12-08 09:41 file1
 -rw-r----- 1 usuario1 usuario1 0 2009-12-08 09:41 file2
# prueba de lectura
us3rlinux@equipo1:/home/usuario1/PRUEBA/carpeta2$ cat file1
us3rlinux@equipo1:/home/usuario1/PRUEBA/carpeta2$ cat file2
# prueba de escritura
us3rlinux@equipo1:/home/usuario1/PRUEBA/carpeta2$ echo 'hola' > file1
us3rlinux@equipo1:/home/usuario1/PRUEBA/carpeta2$ echo 'hola' > file2
bash: file2: Permiso denegado
exit
us3rlinux@equipo1:/home/usuario1/PRUEBA$ whoami
us3rlinux
us3rlinux@equipo1:/home/usuario1/PRUEBA$ exit
exit
usuario1@equipo1:~/PRUEBA$ whoami
usuario1
usuario1@equipo1:~/PRUEBA$
57. Visualizar la trayectoria completa del directorio actual. Crear dos directorios llamados correo y fuentes debajo del directorio actual.  $ pwd /home/usuario1/PRUEBA $ mkdir correo fuentes
58. Posicionarse en el directorio fuentes y crear los directorios dir1, dir2, dir3.  $ cd fuentes $ mkdir dir1 dir2
59. Crear el directorio menus bajo correo sin moverse del directorio actual. $ mkdir ../correo/menus
60. Posicionarse en el directorio HOME. Borrar los directorios que cuelgan de fuentes que acaben en un numero que no sea el 1.  $ cd $HOME $ find PRUEBA/fuentes -type d -name "*1" -exec rm -r {} \;
61. Ver si existe el archivo tty2 en el directorio dev. En caso de que exista, ver su fecha de creacion o actualizacion. $ find -type f -name tty2 /dev
62. Ver los permisos que tienen los archivos que empiecen por tt del directorio /dev. $ ls -l /dev/tt*
63. Visualizar la lista de los archivos ordinarios que estan en el directorio /usr/bin. $ find /usr/bin -type f
64. Visualizar la lista de todos los directorios que cuelgan del raiz. $ ls / $ find / $ find / -maxdepth 1 -type d $ find / -size +3M -type d
65. Visualizar la lista de todos los ficheros que pertenezcan a root.  $ find / -user root -type f
66. Visualizar la lista de todos los ficheros .h del directorio /usr/include. $ find /usr/include -type f -regex ".*.h"
67. Ejecutar todos los comandos que empiecen por ls del directorio /bin. $ ls /bin/ls*
68. Visualizar de que tipo son todos y cada uno de ficheros de todo el arbol del sistema propiedad de un usuario conocido. $ find /home/us3rlinux -exec file --mime-type -0 '{}' \;
69. Crear el directorio uno en el directorio HOME con permiso de escritura y paso para el propietario, de lectura y paso para los usuarios de su mismo grupo y ningun permiso para el resto de usuarios. $ mkdir uno $ chmod u=rw,g=rw,o= uno $ ls -ld uno
70. Crear el directorio uno1 dentro del directorio creado en el ejercicio anterior con todos lo permisos para el usuario, ninguno para los usuarios del grupo y permiso de escritura para el resto de usuarios. $ chmod u=rwx,g=rwx,o= uno $ mkdir uno/uno1 $ chmod u=rwx,g=,o=w uno/uno1 $ ls -ld uno/uno1
71. Copiar todos los ficheros propiedad de un usuario conocido que acaben en un numero en el directorio menus. $ find /home/usuario1 -type f -regex ".*[0-9]" -exec cp -r '{}' PRUEBA/correo/menus/ \;
72. Visualiza con la orden who la relacion de usuarios conectados y sus terminales. Mediante la orden cat, crea un pequeño mensaje desde tu consola y redirigelo a uno de los terminales conectados..  $ cat > /dev/tty (ESPERA A QUE EL USUARIO INTERACTUE CON TECLADO) $ ^D (CTRL D)
73. Crea un archivo de tamaño 0. $ touch nombreDeFichero
74. Visualiza el archivo /etc/motd, que contie los permisos de lectura. A continuacion, buscar todos los directorios que cuelguen del directorio propio y guardarlos en el archivo direc. $ cat /etc/motd $packages can be updated. $updates are security updates.
75. Utilizando de entrada la informacion de los usuarios conectados al sistema, guardar, ordenadas por el campo hora, las lineas correspondientes al usuario que se desee en el archivo persona. $ who | grep $USER | sort -k 4 > persona (SORT ORDENA; )
76. Crear el directorio carpeta debajo del directorio PRUEBA. Quitarle todos 4/ 6 los permisos de lectura. A continuacion, buscar todos los directorios que cuelguen del directorio propio y guardarlos en el archivo direc.   $ mkdir carpeta $ chmod a-r carpeta $ find ~ -type d > direc
77. Volver a realizar la segunda parte del ejercicio anterior, pero redireccionando los errores al fichero malos. Comprobar la informacion del fichero malos.  $ find ~ -type d 2> malo
78. Añadir al fichero direc la lista de todos los ficheros ordinarios que cuelguen de /etc.  $ find /etc -type f >> direc
79. Añadir al archivo nuevalista el/los nombre/s de el/los fichero/s del directorio PRUEBA que contengan en su nombre la cadena "ai", añadiendo el posible error al fichero malos.  $ find ./ -type f -not -iname ai 1> nuevalista 2> malos $ find ./ -type f -iname ai 1> nuevalista 2> malos
80. Sacar por pantalla unicamente el tiempo (buscar comando time) que tarda en ejecutarse el comando who.  $ time `sleep 3` $ time who -p %e
81. Sacar por pantalla un listado completo (buscar comando ps) de los procesos que esta realizando el usuario root.  $ ps -U root -u root u
82. Crear el archivo proceso con los procesos que no tienen ningun terminal asignado. $ ps -U root -u root u | grep -v "`ls /dev`"
83. Añadir al fichero anterior la fecha actual y la trayectoria completa del directorio actual. $ echo "`date + "%A %D"` - `pwd`" >>nuevalista
84. Sacar por pantalla el listado de todos los usuarios conectados ordenados por numero de proceso asignado.  $ ps axu
85. Averiguar cual es la actividad actual del sistema. Para ello visualice un listado completo del estado de todos los procesos que se estan ejecutando en el sistema. $ top -d .1 -n 10
86. Obtener un listado con los siguientes datos de los procesos de su shell actual. $ top -d .1 -n 10
87. Mostrar cuantos usuarios tiene registrados el sistema (el registro de usuarios esta en el archivo /etc/passwd). $ cat /etc/passwd | wc -l   $ useradd -m fulanito   $ usermod -aG adm nombreUsuario
88. Mostrar cuantos usuarios tiene registrados el sistema y que utilizan el interprete bash (debe aparecer al final de la linea /bin/bash o similar). $ cat /etc/passwd | grep bash
89. Mostrar cuantos usuarios hay conectados. $ who -q
90. Mostrar las lineas, de un archivo de texto, empiecen por L (mayuscula o minuscula). $ man gcc > gcc.man_page $ cat gcc.man_page | sed -e 's/ //g' > file.filled $ cat file.filled | grep ^[Ll]
91. Contar las lineas, del ejemplo anterior.  $ cat file.filled | grep ^[Ll] | wc -l
92. Extraer los nombres de usuario (primer campo) del sistema. $ cat /etc/passwd | cut -d ':' -f 1
93. Extraer los nombres de usuario y el shell que utilizan (ultimo campo). $ gawk -F: '{print $1, $7}' /etc/passwd
94. Cambiar la fecha de creacion de un archivo ya previamente creado 5/ 6. $ touch -t 9910011101 good $ ls -l good
95. Calcular la firma md5 de un archivo. $ md5sum good
96. Modificar la firma md5 y detectar que se ha cambiado (revision de firma) $ md5sum good > good.MD5 $ echo hola >> good $ md5sum -c good.MD5 $ md5sum good
97. Monitorear la ocupacion de las particiones en los discos. $ df -lh
98. ?Cual es el proceso que mas carga el procesador?  for x in `seq 1 10`; do ps -eo pid,pcpu,pmem,user,args | sort -r -k 2 | head -n 2; sleep 3; done
99. ?Esta corriendo el proceso bash?  $ ps -eo pid,pcpu,pmem,user,args | grep bash $ ps a | grep bash
100. ?Cuantos procesos que empiecen por k estan corriendo? $ ps -eo args | cut -d ' ' -f 1 | grep ^g | wc -l





TEORIA

PAQUETES:
Los repositorios de Debian contienen mas de 65,000 diferentes paquetes de software. Para obtener una lista actualizada de estos repositorios de Internet, puedes ejecutar el comando de sudo apt-get update. ||| Para buscar palabras clave dentro de estos paquetes, puedes utilizar el comando sudo apt-cache search keyword. ||| Cuando hayas encontrado el paquete que quieres instalar, puedes instalarlo con el comando sudo apt-get install package ||| Importante: Para ejecutar estos comandos tu sistema necesitara acceso a Internet. El comando apt-cache busca repositorios de estos programas de software en Internet



USUARIOS:
Cambiar fecha vencimiento de contraseña: usermod -e

Recuerda que los GID bajo 500 estan reservados para uso del sistema. Puede haber ocasiones en las que quieras asignar un GID menor de 500. Para lograr esto, utiliza -r. La opcion -r asignara un GID al nuevo grupo que sera menor que el estandar mas bajo de UID: # getent group sales

El comando groupadd puede ser ejecutado por el usuario root para crear un nuevo grupo. El comando requiere solamente el nombre del grupo que se creara. La opcion -g puede utilizarse para especificar un id de grupo para el grupo nuevo: # groupadd -g 506 research

Recuerda que los GID bajo 500 estan reservados para uso del sistema. Puede haber ocasiones en las que quieras asignar un GID menor de 500. Para lograr esto, utiliza -r. La opcion -r asignara un GID al nuevo grupo que sera menor que el estandar mas bajo de UID: # groupadd -r sales

El comando groupmod se puede utilizar para cambiar el nombre del grupo (con la opcion -n) o cambiar el GID (con la opcion -g) para el grupo.

Si quieres eliminar un grupo con el comando groupdel, ten en cuenta que los archivos que pertenecen a ese grupo se convertiran en -huerfanos-.: # groupdel clerks

La opcion -D del comando useradd te permitira visualizar o modificar algunos de los valores por defecto utilizados por el comando useradd. Los valores indicados por useradd -D tambien pueden visualizarse o actualizar mediante la manipulacion del archivo /etc/default/useradd: ||| Este archivo contiene muchos comentarios y lineas en blanco, asi que si quieres ver las lineas que no son comentarios o lineas en blanco (la configuracion actual), puede utilizar el siguiente comando grep: ||| La opcion -b te permite especificar un directorio diferente bajo el cual se creara el directorio home del usuario. Por ejemplo: -b /test resultaria en /test/sam siendo el directorio home para una cuenta de usuario llamada sam. ||| La opcion -d te permite especificar un directorio existente o un nuevo directorio para el usuario. Esto debe ser una ruta de acceso completa para el directorio home del usuario. Por ejemplo: -d /home/sam. |||  La opcion -m le dice a useradd que cree el directorio home; esto no es normalmente necesario ya que es el comportamiento predeterminado del comando useradd. Sin embargo, cuando utilices la opcion -k (vease abajo) para especificar un esqueleto de directorio diferente, entonces necesitaras la opcion -m. ||| La opcion -M se utiliza para especificarle al comando useradd que no debe crear el directorio home. ||| shell: Mientras el shell por defecto se especifica en el archivo /etc/default/useradd, tambien puede ser cambaido con la opcion de useradd -s en el momento de la creacion de cuentas. Mas tarde, el administrador puede usar la opcion usermod -s para cambiar el shell o el usuario puede cambiar su shell con el comando chsh. Es comun especificar el shell /sbin/nologin para las cuentas que se vayan a utilizar como cuentas del sistema.

Una vez hayas comprobado que valores se utilizaran por defecto y hayas reunido la informacion sobre el usuario, entonces estas listo para crear una cuenta de usuario. Un ejemplo de un comando useradd usando algunas opciones seria el siguiente: # useradd -u 1000 -g users -G wheel,research -c 'Jane Doe' jane 

El administrador puede utilizar el comando passwd para cambiar la contraseña de la cuenta o establecer una contraseña inicial. Por ejemplo, si el administrador hubiera creado la cuenta jane, entonces ejecutando # passwd jane.

Aunque no aparezca como un comando que deber saber segun los objetivos del curso, el comando chage ofrece muchas opciones para la gestion de la informacion de vencimiento de contraseña que se encuentra en el archivo /etc/shadow. Un buen ejemplo del comando chage seria cambiar el numero maximo de dias para la validez de la contraseña de una persona a 60 dias: # chage -M 60 jane

El comando last es ligeramente diferente de los comandos who y w. Por defecto, tambien muestra el nombre de usuario, terminal y ubicacion del inicio de la sesion, no solo de las sesiones actuales iniciadas en el sistema, sino las sesiones anteriores tambien. A diferencia de los comandos who y w, mostrara la fecha y hora en la que el usuario inicio la sesion. Si el usuario cerro la sesion del sistema, entonces se mostrara el tiempo total de conexion o se mostrara "still logged in" (o «sigue conectado» en español).

El comando last lee la historia completa de la sesion desde el archivo /var/log/wtmp y muestra todos los inicios de sesion y los reinicios por defecto. Un detalle interesante de los registros de reinicio es que se muestra la version del kernel Linux que fue arrancado en lugar de la ubicacion del inicio de la sesion.

Si utilizas la opcion -a sin la opcion -G, solamente tienes que listar los grupos nuevos a los que perteneciera el usuario. Por ejemplo, si el usuario jane pertenece actualmente a los grupos wheel y research, entonces para agregar su cuenta al grupo de desarrollo, ejecuta el siguiente comando: # usermod -aG development jane. ||| Borrar un usuario con el comando userdel (vease la seccion siguiente) puede resultar en archivos huerfanos o eliminados del usuario del sistema. En vez de eliminar la cuenta, otra opcion es bloquear la cuenta con la opcion -L del comando usermod. El bloqueo de una cuenta evita que la cuenta se utilice, pero sigue siendo propietario de los archivos.

La salida de groups puede no ser tan detallada como la salida del comando id, pero si todo lo que necesitas saber es a que grupos puedes cambiar utilizando el comando newgrp, entonces el comando groups proporciona la informacion que necesitas. La salida del comando id muestra tu grupo primario actual, por lo que es util verificar que el comando newgrp tuvo exito.




MANUALES-ESPANOL: # sudo apt install manpages-es manpages-es-extra /// # sudo dpkg-reconfigure locales